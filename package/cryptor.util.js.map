{"version":3,"sources":["../src/cryptor.util.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAAA,2CAA4C;AAC5C,iCAAiC;AAMjC,IAAa,WAAW,GAAxB;IAQU,eAAe,CAAC,QAAgB,EAAE,KAAa;;YACjD,OAAO,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAC3F,CAAC;KAAA;IAQK,SAAS,CAAC,MAAc,EAAE,YAAoB;;YAEhD,MAAM,GAAG,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,CAAC;YAEhE,MAAM,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAE5B,MAAM,MAAM,GAAG,MAAM,CAAC,cAAc,CAAC,aAAa,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;YAE7D,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC,EAAE,MAAM,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YAE7F,OAAO,UAAU,CAAC,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACzC,CAAC;KAAA;IAQK,SAAS,CAAC,MAAc,EAAE,UAAkB;;YAE9C,MAAM,GAAG,GAAG,MAAM,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,EAAE,CAAC;YAEhE,MAAM,EAAE,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;YAE5B,MAAM,QAAQ,GAAG,MAAM,CAAC,gBAAgB,CAAC,aAAa,EAAE,GAAG,EAAE,EAAE,CAAC,CAAC;YAEjE,MAAM,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,UAAU,EAAE,QAAQ,CAAC,EAAE,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC,CAAC;YAE9F,OAAO,YAAY,CAAC,QAAQ,EAAE,CAAC;QACnC,CAAC;KAAA;IAQK,cAAc,CAAC,MAAc,EAAE,eAA8B;;YAC/D,OAAO,OAAO,CAAC,GAAG,CAAC,eAAe,CAAC,GAAG,CAAC,CAAO,IAAI,EAAE,EAAE;gBAClD,OAAO,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YACrD,CAAC,CAAA,CAAC,CAAC,CAAC;QACR,CAAC;KAAA;IAQK,cAAc,CAAC,MAAc,EAAE,aAA4B;;YAC7D,OAAO,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,GAAG,CAAC,CAAO,IAAI,EAAE,EAAE;gBAChD,OAAO,IAAI,GAAG,MAAM,IAAI,CAAC,SAAS,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC;YACrD,CAAC,CAAA,CAAC,CAAC,CAAC;QACR,CAAC;KAAA;CACJ,CAAA;AAzEY,WAAW;IADvB,mBAAU,EAAE;GACA,WAAW,CAyEvB;AAzEY,kCAAW","file":"cryptor.util.js","sourcesContent":["import { Injectable } from \"@nestjs/common\";\nimport * as crypto from \"crypto\";\n\n/**\n * 加密解密工具\n */\n@Injectable()\nexport class CryptorUtil {\n\n    /**\n     * 通过邮箱加密密码\n     *\n     * @param password 密码\n     * @param email 邮箱\n     */\n    async encryptPassword(password: string, email: string) {\n        return crypto.createHash(\"sha256\").update(password + email.substr(2, 8)).digest(\"hex\");\n    }\n\n    /**\n     * 对称加密工具\n     * @param aesKey 密钥\n     * @param originalText 原文\n     * @returns 密文 cipherText\n     */\n    async encryptor(aesKey: string, originalText: string): Promise<string> {\n        // 使用 aesKey 生成加密 key\n        const key = crypto.createHash(\"sha256\").update(aesKey).digest();\n        // 初始化向量，截取key前16字节\n        const iv = key.slice(0, 16);\n        // 使用 aes-256-cbc 算法创建 cipher\n        const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);\n        // 加密\n        const cipherText = Buffer.concat([cipher.update(Buffer.from(originalText)), cipher.final()]);\n        // 返回密文\n        return cipherText.toString(\"base64\");\n    }\n\n    /**\n     * 对称解密工具\n     * @param aesKey 密钥\n     * @param cipherText 密文\n     * @returns 原文 originalText\n     */\n    async decryptor(aesKey: string, cipherText: string): Promise<string> {\n        // 使用 aesKey 生成解密 key\n        const key = crypto.createHash(\"sha256\").update(aesKey).digest();\n        // 初始化向量，截取key前16字节\n        const iv = key.slice(0, 16);\n        // 使用 aes-256-cbc 算法创建 decipher\n        const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n        // 解密\n        const originalText = Buffer.concat([decipher.update(cipherText, \"base64\"), decipher.final()]);\n        // 返回原文\n        return originalText.toString();\n    }\n\n    /**\n     * 批量对称加密工具\n     * @param aesKey 密钥\n     * @param originalTextArr 原文组\n     * @returns 密文组 cipherTextArr\n     */\n    async batchEncryptor(aesKey: string, originalTextArr: Array<string>): Promise<Array<string>> {\n        return Promise.all(originalTextArr.map(async (item) => {\n            return item = await this.encryptor(aesKey, item);\n        }));\n    }\n\n    /**\n     * 批量对称解密工具\n     * @param aesKey 密钥\n     * @param cipherTextArr 密文\n     * @returns 原文组 originalTextArr\n     */\n    async batchDecryptor(aesKey: string, cipherTextArr: Array<string>): Promise<Array<string>> {\n        return Promise.all(cipherTextArr.map(async (item) => {\n            return item = await this.decryptor(aesKey, item);\n        }));\n    }\n}\n"]}